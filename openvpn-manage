#!/bin/bash

##
# Exit with optional message to stderr
##
quit() {
    [[ $2 ]] && echo "$2" >&2
    exit "$1"
}


##
# Convert decimal number to IPv4 address
##
dec2ip() {
    local _var _res _e _dot _octet _dec
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _dec=$1
    for _e in {3..0}; do
        (( _octet = _dec/256**_e ))
        (( _dec -= _octet*256**_e ))
        _res+=${_dot}${_octet}
        _dot=.
    done

    if [[ ${_var} ]]; then eval "${_var}=\${_res}"; else echo "${_res}"; fi
}


##
# Convert IPv4 address to decimal number
##
ip2dec() {
    local _var _res _a _b _c _d
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    IFS=. read -r _a _b _c _d <<<"$1"
    (( _res = _a*256**3 + _b*256**2 + _c*256 + _d ))

    if [[ ${_var} ]]; then eval "${_var}=\${_res}"; else echo "${_res}"; fi
}


##
# Convert IPv4 MASK to CIDR
# Assumes that MASK have no gaps.
##
mask2cidr() {
    local _var _res _x
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _x=${1##*255.}
    set -- 0^^^128^192^224^240^248^252^254^ $(( (${#1}-${#_x})*2 )) "${_x%%.*}"
    _x=${1%%$3*}
    (( _res = $2 + ${#_x}/4 ))

    if [[ ${_var} ]]; then eval "${_var}=\${_res}"; else echo "${_res}"; fi
}


##
# Convert CIDR to IPv4 MASK
##
cidr2mask() {
    local _var _res
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi
    [[ -z $1 ]] && set 0

    set -- $(( 5-($1/8) )) 255 255 255 255 $(( (255<<(8 - ($1%8)))&255 )) 0 0 0
    if (($1 > 1)); then shift "$1"; else shift; fi
    _res=${1:-0}.${2:-0}.${3:-0}.${4:-0}

    if [[ ${_var} ]]; then eval "${_var}=\${_res}"; else echo "${_res}"; fi
}


##
# Return next subnet with the same size
# Subnet format is IPv4/CIDR
##
increment_subnet() {
    local _var _res _ip _cidr _size _ip_dec _ip_next
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _ip=${1%/*}
    _cidr=${1#*/}
    (( _size = 2**(32-_cidr) ))  # all IPs count inside subnet e.g. /29 size is 8
    ip2dec -v _ip_dec "${_ip}"
    dec2ip -v _ip_next $((_size+_ip_dec))
    _res=${_ip_next}/${_cidr}

    if [[ ${_var} ]]; then eval "${_var}=\${_res}"; else echo "${_res}"; fi
}


##
# Validate IPv4 address
# Note: this is invalid address: 192.168.000.001
##
validate_ip4() {
    local _re
    _re='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'
    [[ "$1" =~ ${_re} ]] && return 0 || return 1
}


##
# Validate IPv4/CIDR
##
validate_ip4cidr() {
    local _re
    _re='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\/([0-9]|[1-2][0-9]|3[0-2])$'
    [[ "$1" =~ ${_re} ]] && return 0 || return 1
}


##
# Usage: validate_host_name host_name [regex]
##
validate_host_name() {
    local _re
    if [[ $2 ]]; then
        _re=$2
    elif [[ ${HOST_NAME_ALLOWED_REGEX} ]]; then
        _re=${HOST_NAME_ALLOWED_REGEX}
    else
        _re='^[A-Za-z0-9_-]+$'  # Default regex
    fi
    [[ "$1" =~ ${_re} ]] || quit 1 "Host name restricted to match the following regex: ${_re}"
    return 0
}


##
# Validate that client name starts with 5 digits and '-' then.
# Values '00000-' and '00001-' treated as invalid.
# Include host name validation.
##
validate_client_name() {
    local _re _N
    _re='^[0-9]+-$'
    _N=${1::6}
    [[ "${_N}" =~ ${_re} && "${_N}" != '00000-' && "${_N}" != '00001-' ]] || quit 1 "First 6 symbols of client name must match the following regex: ${_re}"
    validate_host_name "${1:6}" || return 1
    return 0
}


revoke_cert() {
    local _cn
    _cn=$1
    [[ -f "${EASYRSA}/pki/issued/${_cn}.crt" ]] || quit 1 "No such cert: ${_cn}"
    if ! grep -qE "^R[[:space:]]*[[:digit:]]*Z.*/CN=${_cn}(/.*)?$" "${EASYRSA}/pki/index.txt"; then
        ./easyrsa --batch revoke "${_cn}" &>"${DESCRIPTOR}"
        if (($?)); then
            quit 1 "${_cn}: failed to revoke cert"
        else
            echo "${_cn}: cert revoked"
        fi
    else
        echo "${_cn}: cert already revoked!"
    fi
}


disable_client() {
    local _cn
    _cn=$1
    if ! grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        echo disable >>"${CLIENT_CONFIG_DIR}/${_cn}"
        echo "${_cn}: disabled"
    else
        echo "${_cn}: was already disabled!"
    fi
}


enable_client() {
    local _cn
    _cn=$1
    if grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        sed -i '/^disable$/d' "${CLIENT_CONFIG_DIR}/${_cn}"
        echo "${_cn}: enabled"
    else
        echo "${_cn}: was already enabled!"
    fi
}


populate_subnet_var() {
    local _cn CLIENT_SUBNET_BEHIND_IP CLIENT_SUBNET_BEHIND_CIDR ROUTERS_LIST FIRST_ROUTER
    _cn=$1
    ROUTERS_LIST=$(exec -c grep -l '^iroute ' "${CLIENT_CONFIG_DIR}/"*"-${_cn}")
    if (($? == 0)); then  # Other routers exists for this host
        # Get subnet from first available router config of this host!
        read -r FIRST_ROUTER <<<"${ROUTERS_LIST}"
        CLIENT_SUBNET_BEHIND=$(exec -c grep -m1 '^iroute ' "${FIRST_ROUTER}")
        CLIENT_SUBNET_BEHIND=${CLIENT_SUBNET_BEHIND#iroute }
        CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%% *}
        mask2cidr -v CLIENT_SUBNET_BEHIND_CIDR ${CLIENT_SUBNET_BEHIND#* }
        CLIENT_SUBNET_BEHIND=${CLIENT_SUBNET_BEHIND_IP}/${CLIENT_SUBNET_BEHIND_CIDR}
    else  # It's only router for this host: autoincrement subnet
        # Increment last saved subnet
        if [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]]; then
            increment_subnet -v CLIENT_SUBNET_BEHIND "$(< "${LAST_IROUTE_SUBNET_FILE}")"
        else
            CLIENT_SUBNET_BEHIND=${INITIAL_IROUTE_SUBNET}
        fi
        [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]] && mv "${LAST_IROUTE_SUBNET_FILE}"{,.old}
        echo "${CLIENT_SUBNET_BEHIND}" >"${LAST_IROUTE_SUBNET_FILE}"
        echo "Note: LAST_IROUTE_SUBNET was incremented to ${CLIENT_SUBNET_BEHIND}" >&2
    fi
}


update_client() {
    # Update client type and/or subnet
    local _cn OLD_CLIENT_TYPE OLD_IROUTE CLIENT_SUBNET_BEHIND_IP CLIENT_SUBNET_BEHIND_MASK OLD_CLIENT_SUBNET_BEHIND OLD_CLIENT_SUBNET_BEHIND_IP OLD_CLIENT_SUBNET_BEHIND_CIDR
    _cn=$1
    if grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        OLD_CLIENT_TYPE=router
        OLD_IROUTE=$(exec -c grep -m1 '^iroute ' "${CLIENT_CONFIG_DIR}/${_cn}")
        OLD_CLIENT_SUBNET_BEHIND=${OLD_IROUTE#iroute }
        OLD_CLIENT_SUBNET_BEHIND_IP=${OLD_CLIENT_SUBNET_BEHIND%% *}
        mask2cidr -v OLD_CLIENT_SUBNET_BEHIND_CIDR ${OLD_CLIENT_SUBNET_BEHIND#* }
        OLD_CLIENT_SUBNET_BEHIND=${OLD_CLIENT_SUBNET_BEHIND_IP}/${OLD_CLIENT_SUBNET_BEHIND_CIDR}
    else
        OLD_CLIENT_TYPE=user
    fi

    case "${CLIENT_TYPE}" in
        user)
            if [[ "${CLIENT_TYPE}" != "${OLD_CLIENT_TYPE}" ]]; then  # router -> user
                sed -i -e '/^iroute /d' -e "1 a config ${USERS_CONF_IN_CHROOT}" "${CLIENT_CONFIG_DIR}/${_cn}"
                echo "${_cn}: type changed to ${CLIENT_TYPE}"
            else  # user -> user: nothing to change
                echo "${_cn}: type is already ${CLIENT_TYPE}!"
            fi
            ;;
        router)
            if [[ -z "${CLIENT_SUBNET_BEHIND}" ]]; then
                populate_subnet_var "${_cn:6}"
            fi

            CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%%/*}
            cidr2mask -v CLIENT_SUBNET_BEHIND_MASK ${CLIENT_SUBNET_BEHIND#*/}
            if [[ "${CLIENT_TYPE}" != "${OLD_CLIENT_TYPE}" ]]; then  # user -> router
                sed -i -e '/^config /d' -e "1 a iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}" "${CLIENT_CONFIG_DIR}/${_cn}"
                echo "${_cn}: internal subnet changed to ${CLIENT_SUBNET_BEHIND}"
            else  # router -> router: change router subnet only
                if [[ "${OLD_CLIENT_SUBNET_BEHIND}" != "${CLIENT_SUBNET_BEHIND}" ]]; then
                    sed -i "s/${OLD_IROUTE}/iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}/" "${CLIENT_CONFIG_DIR}/${_cn}"
                    echo "${_cn}: internal subnet changed to ${CLIENT_SUBNET_BEHIND}"
                else
                    echo "${_cn}: already has internal subnet ${CLIENT_SUBNET_BEHIND}!"
                fi
            fi
            ;;
    esac

    # Enable/disable if -e|-d specified
    [[ "${ENABLED}" == yes ]] && enable_client "${_cn}"
    [[ "${ENABLED}" == no ]] && disable_client "${_cn}"
}


show_client() {
    local CLIENT_NAME ENABLED VALID_CERT CLIENT_TYPE IROUTES IROUTE IP CIDR USERS_CONF_LINE line n N SUBNET CLIENT_CONFIG CCC
    SUBNET=''
    CLIENT_NAME=$1
    CLIENT_CONFIG="${CLIENT_CONFIG_DIR}/${CLIENT_NAME}"
    CCC=$(< "${CLIENT_CONFIG}")

    if grep -q '^disable$' <<<"${CCC}"; then
        ENABLED=no
    else
        ENABLED=yes
    fi

    IROUTES=$(exec -c grep '^iroute ' <<<"${CCC}")
    if (($? == 0)); then
        CLIENT_TYPE=router
        while read IROUTE; do
            IROUTE=${IROUTE#iroute }
            IP=${IROUTE%% *}
            mask2cidr -v CIDR ${IROUTE#* }
            [[ ${SUBNET} ]] && SUBNET+=','
            SUBNET+="${IP}/${CIDR}"
        done <<<"${IROUTES}"
    fi
    USERS_CONF_LINE=$(exec -c grep "^config ${USERS_CONF_IN_CHROOT}$" <<<"${CCC}")
    if (($? == 0)); then
        CLIENT_TYPE=user
    fi
    if [[ -n "${IROUTES}" && -n "${USERS_CONF_LINE}" ]]; then
        CLIENT_TYPE=mixed
    elif [[ -z "${IROUTES}" && -z "${USERS_CONF_LINE}" ]]; then
        CLIENT_TYPE=unspecified
    fi

    (( N = 10#${CLIENT_NAME::5} ))
    n=0
    while read line; do
        ((n++))
        if [[ ${n} -eq ${N} ]]; then
            if [[ "${line::1}" == 'R' ]]; then
                VALID_CERT=no
            else
                VALID_CERT=yes
            fi
            break
        fi
    done <"${EASYRSA}/pki/index.txt"

    echo "${CLIENT_NAME}:
    Server side config: ${CLIENT_CONFIG}
    Enabled: ${ENABLED}
    Valid cert: ${VALID_CERT}
    Type: ${CLIENT_TYPE}"
    if [[ "${CLIENT_TYPE}" == 'router' || "${CLIENT_TYPE}" == 'mixed' ]]; then
        echo "    Internal subnets: ${SUBNET}"
    fi
    if [[ "${CLIENT_TYPE}" == 'user' || "${CLIENT_TYPE}" == 'mixed' ]]; then
        echo "    Users shared config: ${USERS_CONF}"
    fi
}


add_client() {
    local HOST_NAME FLNUMBER NUMBER USER CLIENT_CONFIG_NAME DEC_IP srv TMP_USER_DIR
    HOST_NAME=$1
    printf -v FLNUMBER '%05d' $(( 16#$(< "${EASYRSA}/pki/serial") ))
    (( NUMBER = 10#${FLNUMBER} ))
    USER="${FLNUMBER}-${HOST_NAME}"
    case "${CLIENT_OS}" in
        windows)
            CLIENT_CONFIG_NAME="${USER}.ovpn"
            eval "read -rd '' OS_SPECIFIC_OPTIONS <<EOF${BR}${WIN_SPECIFIC_OPTIONS}${BR}EOF"
            ;;
        *)
            CLIENT_CONFIG_NAME="${USER}.conf"
            eval "read -rd '' OS_SPECIFIC_OPTIONS <<EOF${BR}${NIX_SPECIFIC_OPTIONS}${BR}EOF"
    esac

    cd "${EASYRSA}"

    ./easyrsa --batch --req-cn="${USER}" gen-req "${USER}" nopass &>"${DESCRIPTOR}" || quit 1 "Easyrsa error: $?"
    ./easyrsa --batch --req-cn="${USER}" sign-req client "${USER}" &>"${DESCRIPTOR}" || quit 1 "Easyrsa error: $?"

    # Change CN in Authority Key Identifier DirName for compatibility with Netcomm routers openvpn interface
    sed -i -e "s/\/CN=server\//\/CN=${USER}\//" -e "s/\/CN=server$/\/CN=${USER}/" "${EASYRSA}/pki/issued/${USER}.crt"

    # Calculate client OVPN IP and NETMASK
    srv=$(exec -c grep -m1 '^server ' "${SERVER_CONF}")
    srv=${srv#server }
    srv=${srv% nopool*}
    ip2dec -v DEC_IP ${srv%% *}
    dec2ip -v CLIENT_OVPN_IP $((DEC_IP+NUMBER))
    NETMASK=${srv#* }

    ## Number for ethN and tunN, first host cert will have N=0, 2nd - N=1 etc.
    N=$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" 2>/dev/null | wc -l)

    # Create symlinks if possible, copy otherwise
    if ln -s "${EASYRSA}/pki/issued/${USER}.crt" "${CLIENT_KEYS_DIR}" >/dev/null; then
        ln -s "${EASYRSA}/pki/private/${USER}.key" "${CLIENT_KEYS_DIR}"
    else
        cp "${EASYRSA}/pki/issued/${USER}.crt" "${EASYRSA}/pki/private/${USER}.key" "${CLIENT_KEYS_DIR}"
    fi
    echo "ifconfig-push ${CLIENT_OVPN_IP} ${NETMASK}" >"${CLIENT_CONFIG_DIR}/${USER}"

    case "${CLIENT_TYPE}" in
        user)
            echo "config ${USERS_CONF_IN_CHROOT}" >>"${CLIENT_CONFIG_DIR}/${USER}"
        ;;
        router)
            CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%%/*}
            cidr2mask -v CLIENT_SUBNET_BEHIND_MASK ${CLIENT_SUBNET_BEHIND#*/}
            echo "iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}" >>"${CLIENT_CONFIG_DIR}/${USER}"
            ROUTER_CONF_STR='# On config creation time vpn-server used the following internal subnet for this client:'
            ROUTER_CONF_STR+="# ${CLIENT_SUBNET_BEHIND}"
            ROUTER_CONF_STR+='# It should match real internal subnet if you want allow vpn-users access it.'
            ROUTER_CONF_STR+='# Forwarding should be enabled for vpn<->subnet interfaces.'
        ;;
    esac

    if [[ ${D} ]]; then
        disable_client "${USER}"
    fi

    chown :"${OPENVPN_GROUP}" "${CLIENT_CONFIG_DIR}/${USER}"
    chmod 640 "${CLIENT_CONFIG_DIR}/${USER}"

    # chown :${OPENVPN_GROUP} "${EASYRSA}/pki/index.txt"
    # chmod 640 "${EASYRSA}/pki/index.txt"
    # chmod og+x "${EASYRSA}/pki"{,/issued,/private}

    # cp "${EASYRSA}/pki/issued/${USER}.crt" "${EASYRSA}/pki/private/${USER}.key" "${KEYS_DIR}/ca.crt" "${KEYS_DIR}/ta.key" temp
    mkdir -p "${CLIENT_PACKS_DIR}/${HOST_NAME}"

    # Write client config
    eval "read -rd '' CLIENT_CONFIG <<EOF${BR}${CLIENT_CONFIG_TEMPLATE}${BR}EOF"
    echo "${CLIENT_CONFIG}" >"${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}"
    # (set -o posix; set) >&2

    # .zip pack beside all-in-one config
    # Include:
    #     ${USER}.tgz with ca.crt ${USER}.key ${USER}.crt
    #     ta.key
    #     ${USER} all-in-one conf
    TMP_USER_DIR="/tmp/openvpn-manage/${USER}"
    mkdir -p "${TMP_USER_DIR}"
    tar --transform 's/.*\///g' -zchf "${TMP_USER_DIR}/${USER}.tgz" "./pki/private/${USER}.key" "./pki/issued/${USER}.crt" ./pki/ca.crt &>"${DESCRIPTOR}"
    cp -l ./pki/ta.key "${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}" || \
        cp ./pki/ta.key "${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"
    zip -rjD "${CLIENT_PACKS_DIR}/${HOST_NAME}/${USER}.zip" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"
    rm "${TMP_USER_DIR}/"{"${USER}.tgz",ta.key,"${CLIENT_CONFIG_NAME}"} &>"${DESCRIPTOR}" && rm -r "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"

    [[ ${DESCRIPTOR} == /dev/null ]] || echo "${BR}${BR}"
    echo "${USER}: config created:${BR}${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}"
    cd - >/dev/null
}


create_host() {
    local HOST_NAME COUNT INCSUB
    HOST_NAME=$1
    [[ $2 ]] && COUNT=$2 || COUNT=1
    if (( COUNT <= 0 )); then
        quit 1 "Invalid COUNT: ${COUNT}"
    fi

    for ((n=1;n<=COUNT;++n)); do
        INCSUB=no  # Is subnet was incremented?
        if [[ "${CLIENT_TYPE}" == router ]]; then
            if [[ -z "${CLIENT_SUBNET_BEHIND}" ]]; then
                # Increment last saved subnet
                if [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]]; then
                    increment_subnet -v CLIENT_SUBNET_BEHIND "$(< "${LAST_IROUTE_SUBNET_FILE}")"
                else
                    CLIENT_SUBNET_BEHIND=${INITIAL_IROUTE_SUBNET}
                fi
                INCSUB=yes
            fi
            if [[ -z "${S}" ]]; then  # If not specified in command line
                validate_ip4cidr "${CLIENT_SUBNET_BEHIND}" || quit 1 "Invalid subnet: ${CLIENT_SUBNET_BEHIND}"
            fi
        fi

        add_client "${HOST_NAME}"

        if [[ $? -eq 0 && "${INCSUB}" == yes ]]; then
            [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]] && mv "${LAST_IROUTE_SUBNET_FILE}"{,.old}
            echo "${CLIENT_SUBNET_BEHIND}" >"${LAST_IROUTE_SUBNET_FILE}"
            echo "Note: LAST_IROUTE_SUBNET was incremented to ${CLIENT_SUBNET_BEHIND}" >&2
        fi
        if [[ "${CLIENT_TYPE}" == router ]]; then
            echo "Router internal subnet set to ${CLIENT_SUBNET_BEHIND}"
        fi
        echo
    done

    zip --exclude \*.zip -rjD "${CLIENT_PACKS_DIR}/${HOST_NAME}.zip" "${CLIENT_PACKS_DIR}/${HOST_NAME}/" >/dev/null
    echo
    echo "Host pack with client configs created:${BR}${CLIENT_PACKS_DIR}/${HOST_NAME}.zip"
}


find_client_names() {
    # Return array of client names for specified host_name
    local _var _res _host_name _filename
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi
    _res=()
    _host_name=$1
    for _filename in "${CLIENT_PACKS_DIR}/${_host_name}/"*.{ovpn,conf}; do
        _filename=${_filename##*/}
        _filename=${_filename%.ovpn}
        _filename=${_filename%.conf}
        [[ "${_filename}" == '*' ]] && continue
        _res+=("${_filename}")
    done

    if [[ ${_var} ]]; then eval "${_var}=(\${_res[@]})"; else echo "${_res[@]}"; fi
}

BR=$'\n'

read -rd '' USAGE <<'EOF'
Usage:
    openvpn-manage ACTION { PARAMS } [ OPTIONS ]
    ACTION := { usage | help | create | append | enable | disable | revoke | list | show }
    OPTIONS := { -f CONF | -t CLIENT_TYPE | -s IP/CIDR | -c COUNT | -o CLIENT_OS | -e | -d | -v }
    CLIENT_TYPE := { user | router }
    CLIENT_OS := { windows | nix }

    openvpn-manage { create | append } HOST_NAME [ OPTIONS ]

    openvpn-manage { enable | disable | revoke } { host HOST_NAME | client CLIENT_NAME }

    openvpn-manage list { host[s] | client[s] } [ HOST_NAME ] { -t CLIENT_TYPE | -s CLIENT_SUBNET_BEHIND | -e | -d }

    openvpn-manage show { host HOST_NAME | client CLIENT_NAME }
EOF

read -rd '' HELP <<EOF
${USAGE}

Description:
    "host" is the name of specific host (specific host can have several clients/certs).
    "client" is specific vpn-client/cert for the host.

Actions:
    create host HOST_NAME
    append client HOST_NAME
        Used for create/append clients to HOST_NAME.
        Difference is:
        validation - you can't create host if HOST_NAME already exist and you can't
            append clients to non-existent host.
        subnet applying for type router - for "append" if -s not specified additional clients of
            the host will have the same subnet as first available iroute option
            in first available client config.

    enable, disable, revoke
        You can enable/disable/revoke specific client (client CLIENT_NAME) or all clients
        (host HOST_NAME) of the host.
        Enable and disable just delete/add 'disable' line to client config, so client can't
        connect. Host/client can be enabled/disabled any time.
        revoke adds client[s] cert[s] to revocation list, so it could be treated as
        persistent client deactivation.
        Note: revoked cert still can be unrevoked manually, but it's not supported
        by openvpn-manage.

    list
        List hosts or clients depends on filter options.
        For HOST_NAME grep standard regexp's supported.
        Examples:
            List all hosts:
                list hosts
            List all routers clients:
                list clients -t router
            List enabled clients of specific host with specified internal subnet:
                list clients HOST_NAME -e -s 10.10.0.8/29

Options:
    -f CONF
        Configuration file of openvpn-manage
        Default: /etc/openvpn/server/scripts/openvpn-manage.conf

    -t CLIENT_TYPE
        Could be "user" (default) or "router". Difference is client config options.
        User config contain push "route ..." to the routers internal subnets.
        Router config contain iroute to internal subnet behind it.

    -s CLIENT_SUBNET_BEHIND
        Format: IP/CIDR. Subnet behind the router. Valid only if CLIENT_TYPE is "router".
        If no subnet specified subnet will be incremented from the last saved subnet.
        Subnet will be saved to LAST_IROUTE_SUBNET_FILE. If no file exist
        INITIAL_IROUTE_SUBNET will be used and then saved to LAST_IROUTE_SUBNET_FILE.
        Subnet will be saved only if -s option omitted, so manually specified subnet
        will not be saved in LAST_IROUTE_SUBNET_FILE. It's allow manually specify
        subnet without interrupt existing subnet chain.

    -c COUNT
        Default is 1. Allow to create COUNT clients/certs for the host with single
        command. Additional host clients/certs could be added via action "append"
        next time.

    -e, -d
        List enabled/disabled only.

    -v
        Verbose output.
EOF


# Main case: Parse positional arguments
case "$1" in
    ''|usage) quit 255 "${USAGE}"; ;;

    help) quit 255 "${HELP}"; ;;

    *)  # Parse args, verify, apply defaults.
        # Really not for all actions root required, but to be sure...
        # ((UID)) && quit 2 'Root privileges required'

        [[ $2 ]] || quit 1 "Action requires parameter!"
        unset HELP USAGE

        ## Defaults
        DESCRIPTOR=/dev/null  # Default if no -v option specified
        CONF='/etc/openvpn/server/scripts/openvpn-manage.conf'

        # Options below can be overwrited in CONF file
        CA_PASS=no  # 'yes' if CA is password protected
        SERVER_DIR='/etc/openvpn/server'
        KEYS_DIR="${SERVER_DIR}/keys"
        CLIENT_KEYS_DIR="${SERVER_DIR}/client-keys"
        CLIENT_PACKS_DIR="${SERVER_DIR}/client-packs"
        CLIENT_CONFIG_DIR="${SERVER_DIR}/client-configs"
        USERS_CONF="${SERVER_DIR}/users-config"
        SERVER_CONF="${SERVER_DIR}/server.conf"  # If tcp and udp servers subnet are the same, any config is fine here
        EASYRSA='/etc/openvpn/easy-rsa/easyrsa3'
        CLIENT_OS_DEFAULT='nix'  # 'nix' for Unix-based OS, 'windows' for Windows
        OPENVPN_USER=openvpn
        OPENVPN_GROUP=openvpn
        INITIAL_IROUTE_SUBNET='10.10.0.0/29'
        LAST_IROUTE_SUBNET_FILE="${SERVER_DIR}/last_iroute_subnet"
        HOST_NAME_ALLOWED_REGEX='^[A-Za-z0-9_-]+$'
        ALLOW_DIFFERENT_CLIENT_TYPES_FOR_HOST=no
        ## END Defaults

        ## Parse options
        # Calculate first option position
        for ((i=1;i<=$#;++i)); do
            if [[ "${!i::1}" == '-' ]]; then
                OPTIND=$i
                break
            fi
        done
        while getopts ":vedt:o:s:c:f:" OPT; do
            [[ "${OPTARG::1}" = '-' ]] && quit 1 "Option argument can not start with '-'"
            case "$OPT" in
                v) DESCRIPTOR=/dev/stdout; V='-v'; ;;
                e) ENABLED=yes; E='-e'; ;;
                d) ENABLED=no; D='-d'; ;;
                t) CLIENT_TYPE=${OPTARG}; T='-t'; ;;
                o) CLIENT_OS=${OPTARG}; O='-o';
                    case "${CLIENT_OS}" in
                        linux|mac|bsd) CLIENT_OS=nix; ;;
                        windows|nix) ;;
                        *) quit 1 "Invalid OS: ${CLIENT_OS}${BR}"'Have to be "windows" or "nix" (for Linux/Mac/BSD/etc). "linux", "mac", "bsd" translated to "nix".'
                    esac
                    ;;
                s) CLIENT_SUBNET_BEHIND=${OPTARG}; S='-s';
                    validate_ip4cidr "${CLIENT_SUBNET_BEHIND}" || quit 1 "Invalid subnet: ${CLIENT_SUBNET_BEHIND}"
                    ;;
                c) COUNT=${OPTARG}; C='-c'; ;;
                f) CONF=${OPTARG}; F='-f'; ;;
                :) quit 1 "Option -$OPTARG requires an argument"; ;;
                *) quit 1 "Invalid option: -$OPTARG"; ;;
            esac
        done
        # OPTIND=1

        # Import configuration file
        . "${CONF}"
        (($?)) && quit 1 "Failed to import configuration file: ${CONF}"
        # echo "${CLIENT_CONFIG_TEMPLATE}" >&2

        CHROOT=$(exec -c grep -m1 '^chroot ' "${SERVER_CONF}")
        CHROOT=${CHROOT#chroot }
        if [[ -n "${CHROOT}" && "${CHROOT}" != '/' ]]; then
            USERS_CONF_IN_CHROOT=${USERS_CONF##*/}  # E.g. users-config
        else
            USERS_CONF_IN_CHROOT=${USERS_CONF}
        fi

        # Verification of config options
        [[ -d "${CHROOT}" ]] || quit 1 "Chroot server dir have to exist for current configuration: ${CHROOT}"
        [[ -d "${SERVER_DIR}" ]] || quit 1 "Server dir does not exist: ${SERVER_DIR}"
        [[ -d "${KEYS_DIR}" ]] || quit 1 "Keys dir does not exist: ${KEYS_DIR}"
        [[ -d "${CLIENT_KEYS_DIR}" ]] || quit 1 "Clients keys dir does not exist: ${CLIENT_KEYS_DIR}"
        [[ -d "${CLIENT_PACKS_DIR}" ]] || quit 1 "Clients packages dir dir does not exist: ${CLIENT_PACKS_DIR}"
        [[ -d "${CLIENT_CONFIG_DIR}" ]] || quit 1 "Clients config dir dir does not exist: ${CLIENT_CONFIG_DIR}"
        [[ -f "${USERS_CONF}" ]] || quit 1 "Users shared config file does not exist: ${USERS_CONF}"
        [[ -f "${SERVER_CONF}" ]] || quit 1 "OpenVPN server config file does not exist: ${SERVER_CONF}"
        [[ -d "${EASYRSA}" ]] || quit 1 "EASYRSA dir does not exist: ${EASYRSA}"
        [[ -f "${EASYRSA}/pki/crl.pem" ]] || quit 1 "Certificate revocation list file does not exist: ${EASYRSA}/pki/crl.pem"
        getent passwd "${OPENVPN_USER}" &>/dev/null || quit 1 "No such user: ${OPENVPN_USER}"
        getent group "${OPENVPN_GROUP}" &>/dev/null || quit 1 "No such group: ${OPENVPN_GROUP}"


        [[ -z ${CLIENT_OS} ]] && CLIENT_OS=${CLIENT_OS_DEFAULT}

        if [[ -n $E && -n $D ]]; then
            quit 1 "Options -e and -d can not be specified simultaneously!"
        fi

        case "${CLIENT_TYPE}" in
            '') CLIENT_TYPE=user; ;;
            user|router) ;;
            *) quit 1 "Invalid argument for -t option: ${CLIENT_TYPE}"; ;;
        esac

        if [[ -n "${S}" && "${CLIENT_TYPE}" != router ]]; then
            quit 1 "Subnet can be specified for type \"router\" only"
        fi

        case "${COUNT}" in
            '') COUNT=1; ;;
            *[^0-9]*) quit 1 "Invalid COUNT: ${COUNT}"; ;;
        esac
        ;;&

    create)
        HOST_NAME=$2
        [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
        validate_host_name "${HOST_NAME}"
        if [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
            quit 1 "Host already exist: ${HOST_NAME}${BR}Use \"append\" to append clients to existing host."
        fi
        ;;&

    append)
        HOST_NAME=$2
        [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
        validate_host_name "${HOST_NAME}"
        if ! [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
            quit 1 "Host does not exist: ${HOST_NAME}${BR}Use 'create' to create new host."
        fi

        for i in "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}"; do FIRST_CLIENT_CONFIG_FILE=$i; break; done
        if grep -q '^iroute ' "${FIRST_CLIENT_CONFIG_FILE}"; then
            # Use the same client type as other clients has
            CLIENT_TYPE_PREVIOUS=router
        else
            CLIENT_TYPE_PREVIOUS=user
        fi
        if [[ "${CLIENT_TYPE_PREVIOUS}" != "${CLIENT_TYPE}" ]]; then
            if [[ "${ALLOW_DIFFERENT_CLIENT_TYPES_FOR_HOST}" == yes ]]; then
                if [[ ${T} ]]; then  # Specified in command line explicitly
                    [[ ${V} ]] && echo "Warning: Client type specified in command line doesn't match the type of previous clients for this host!" &>"${DESCRIPTOR}"
                else
                    CLIENT_TYPE=${CLIENT_TYPE_PREVIOUS}
                fi
            else
                [[ $T ]] && quit 1 "Client type specified in command line doesn't match the type of previous clients for this host!${BR}Remove it or specify proper type."
                CLIENT_TYPE=${CLIENT_TYPE_PREVIOUS}
            fi
        fi
        if [[ "${CLIENT_TYPE}" == router && -z "${S}" ]]; then
            populate_subnet_var "${HOST_NAME}"
        fi

        # Reuse previous CLIENT_OS if commandline option '-o' ommited
        for i in "${CLIENT_PACKS_DIR}/${HOST_NAME}/"*[np][fn]; do FIRST_EXT=${i##*.}; break; done
        if [[ -z "$O" ]]; then
            if [[ "${FIRST_EXT}" == 'ovpn' ]]; then
                CLIENT_OS=windows
            else
                CLIENT_OS=nix
            fi
        fi
        ;;&

    create|append)
        [[ -z ${CLIENT_CONFIG_TEMPLATE} ]] && quit 1 'CLIENT_CONFIG_TEMPLATE variable required, you have to set it in configuration file.'
        create_host "${HOST_NAME}" "${COUNT}"
        ;;

    enable|disable|revoke|update|show)
        case "$2" in
            client)
                CLIENT_NAME=$3
                [[ ${CLIENT_NAME} ]] || quit 1 "You have to specify CLIENT_NAME"
                validate_client_name "${CLIENT_NAME}"
                if ! [[ -f "${CLIENT_CONFIG_DIR}/${CLIENT_NAME}" ]]; then
                    quit 1 "No such client or client config is absent: ${CLIENT_NAME}"
                fi
                ;;
            host)
                HOST_NAME=$3
                [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
                validate_host_name "${HOST_NAME}"
                if ! [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
                    quit 1 "No such host: ${HOST_NAME}"
                fi
                ;;
            *) quit 1 "Invalid parameter: $2"
        esac
        ;;&

    enable)
        case "$2" in
            client)
                enable_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do enable_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was enabled"
                ;;
        esac
        ;;

    disable)
        case "$2" in
            client)
                disable_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do disable_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was disabled"
                ;;
        esac
        ;;

    revoke)
        cd "${EASYRSA}"
        case "$2" in
            client)
                revoke_cert "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do revoke_cert "${cn}"; done
                echo "${BR}All certs of ${HOST_NAME} was revoked"
                ;;
        esac
        ./easyrsa --batch gen-crl &>"${DESCRIPTOR}" && echo "Revocation list was updated" \
                                                || quit 1 "Failed to update revocation list!"
        chown :"${OPENVPN_GROUP}" "${EASYRSA}/pki/crl.pem"
        chmod 440 "${EASYRSA}/pki/crl.pem"
        # chown :${OPENVPN_GROUP} "${EASYRSA}/pki/index.txt"
        # chmod 640 "${EASYRSA}/pki/index.txt"
        # chmod g+x "${EASYRSA}/pki"
        cd - >/dev/null
        ;;

    update)  # Update type and/or subnet
        case "$2" in
            client)
                update_client "${CLIENT_NAME}"
                ;;
            host)
                # quit 254 "Update all host clients feature does not implemented yet. Use it with single client."
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do update_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was updated"
                ;;
        esac
        ;;

    list)  # TODO: finish
        case "$2" in
            clients|client)
                OUT=$(ls -1 "${CLIENT_CONFIG_DIR}" | grep -v '^DEFAULT$')  # All clients/certs
                if [[ -z $3 ]]; then
                    [[ ${OUT} ]] && echo "${OUT}" || quit 1 "No clients match!"
                    exit 0
                elif [[ "${3::1}" != '-' ]]; then
                    # Filter by HOST_NAME
                    HOST_NAME=$3
                    OUT=$(exec -c grep "^[[:digit:]]*-${HOST_NAME}$" <<<"${OUT}")
                    [[ ${OUT} ]] || quit 1 "No clients match!"
                    # [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]] || quit 1 "No such host: ${HOST_NAME}"
                    # ls -1 "${CLIENT_CONFIG_DIR}" | grep "^[[:digit:]]*-${HOST_NAME}$"
                    # find "${CLIENT_CONFIG_DIR}" -maxdepth 1 -mindepth 1 -type f -name "[0-9]+-$3" -printf "%f\n"  | awk -F / '{print $NF}' | cut -d- -f2- | sort -u
                fi

                # Filter by options
                if [[ $T ]]; then
                    case "${CLIENT_TYPE}" in
                        router)
                            OUT=$(while read client; do
                                    grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                                done <<<"${OUT}")
                            ;;
                        user)
                            OUT=$(while read client; do
                                    grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${client}" || echo "${client}";
                                done <<<"${OUT}")
                            ;;
                    esac
                fi
                if [[ $D ]]; then
                    OUT=$(while read client; do
                            grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                        done <<<"${OUT}")
                elif [[ $E ]]; then
                    OUT=$(while read client; do
                            grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" || echo "${client}";
                        done <<<"${OUT}")
                fi
                if [[ $S ]]; then
                    IP=${CLIENT_SUBNET_BEHIND%%/*}
                    cidr2mask -v MASK ${CLIENT_SUBNET_BEHIND#*/}
                    OUT=$(while read client; do
                            grep -q "^iroute ${IP} ${MASK}" "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                        done <<<"${OUT}")
                fi
                # if [[ $O ]]; then
                #     # Can be manually changed by user, so skip implementing this filter.
                # fi

                [[ ${OUT} ]] && echo "${OUT}" || quit 1 "No clients match!"
                ;;
            hosts|host)
                OUT=$(ls -1 "${CLIENT_CONFIG_DIR}" | grep -v '^DEFAULT$' | cut -d- -f2- | sort -u)  # All hosts
                if [[ -z $3 ]]; then
                    [[ ${OUT} ]] && echo "${OUT}" || quit 1 "No hosts match!"
                    exit 0
                elif [[ "${3::1}" != '-' ]]; then
                    # Filter by HOST_NAME
                    HOST_NAME=$3
                    OUT=$(exec -c grep "^${HOST_NAME}$" <<<"${OUT}")
                    [[ ${OUT} ]] || quit 1 "No hosts match!"
                fi

                # Filter by options
                if [[ $T ]]; then
                    case "${CLIENT_TYPE}" in
                        router)
                            OUT=$(while read HOST_NAME; do
                                    grep -q '^iroute ' "$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" | head -1)" \
                                    && echo "${HOST_NAME}";
                                done <<<"${OUT}")
                            ;;
                        user)
                            OUT=$(while read HOST_NAME; do
                                    grep -q '^iroute ' "$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" | head -1)" \
                                    || echo "${HOST_NAME}";
                                done <<<"${OUT}")
                            ;;
                    esac
                fi
                if [[ $D ]]; then
                    # The host treated as disabled if all its clients disabled
                    quit 254 "-d filter for hosts is not implemented yet"
                    # OUT=$(while read HOST_NAME; do
                    #         grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" && echo "${HOST_NAME}";
                    #     done <<<"${OUT}")
                elif [[ $E ]]; then
                    # The host treated as enabled if at least one of its clients enabled
                    quit 254 "-e filter for hosts is not implemented yet"
                fi
                if [[ $S ]]; then
                    quit 254 "-s filter for hosts is not implemented yet"
                fi

                [[ ${OUT} ]] && echo "${OUT}" || quit 1 "No hosts match!"
                ;;
            *) quit 1 "Invalid parameter: $2"
        esac
        ;;

    show)
        case "$2" in
            client)
                show_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do show_client "${cn}"; echo; done
                ;;
        esac
        ;;

    *)                                                                                                                                                                                                                 EE=${BR}${BR}'But don'$'\'''t be upset! Pet the croco and go ahead to eat some cookies!'$'\n'; KOTEHOK=$'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x2e\x2e\x2d\x2d\x27\x27\x60\x60\x2d\x2d\x2d\x2e\x2e\x2e\x2e\x5f\x5f\x5f\x20\x20\x20\x5f\x2e\x2e\x2e\x5f\x20\x20\x20\x20\x5f\x5f\x0a\x2f\x2f\x2f\x20\x2f\x2f\x5f\x2e\x2d\x27\x20\x20\x20\x20\x2e\x2d\x2f\x22\x3b\x20\x20\x60\x20\x20\x20\x20\x20\x20\x20\x20\x60\x60\x3c\x2e\x5f\x20\x20\x60\x60\x2e\x27\x27\x5f\x20\x60\x2e\x20\x2f\x20\x2f\x2f\x20\x2f\x0a\x2f\x2f\x2f\x5f\x2e\x2d\x27\x20\x5f\x2e\x2e\x2d\x2d\x2e\x27\x5f\x20\x20\x20\x20\x5c\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x60\x28\x20\x29\x20\x29\x20\x2f\x2f\x20\x2f\x2f\x0a\x2f\x20\x28\x5f\x2e\x2e\x2d\x27\x20\x2f\x2f\x20\x28\x3c\x20\x5f\x20\x20\x20\x20\x20\x3b\x5f\x2e\x2e\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x3b\x20\x60\x27\x20\x2f\x20\x2f\x2f\x2f\x0a\x2f\x20\x2f\x2f\x20\x2f\x2f\x20\x2f\x2f\x20\x20\x60\x2d\x2e\x5f\x2c\x5f\x29\x27\x20\x2f\x2f\x20\x2f\x20\x60\x60\x2d\x2d\x2e\x2e\x2e\x5f\x5f\x5f\x5f\x2e\x2e\x2d\x27\x20\x2f\x2f\x2f\x20\x2f\x20\x2f\x2f\x27\x0a'; HEKOTEHOK=$'\x20\x20\x20\x20\x20\x20\x5f\x3d\x2c\x5f\x0a\x20\x20\x20\x6f\x5f\x2f\x36\x20\x2f\x23\x20\x20\x20\x5c\x5f\x5f\x20\x7c\x23\x23\x2f\x0a\x20\x20\x20\x20\x3d\x27\x7c\x2d\x2d\x20\x20\x20\x20\x20\x20\x2f\x20\x20\x20\x23\x27\x2d\x2e\x0a\x20\x20\x20\x20\x20\x20\x5c\x23\x7c\x5f\x20\x20\x20\x5f\x27\x2d\x2e\x20\x2f\x0a\x20\x20\x20\x20\x20\x20\x20\x7c\x2f\x20\x5c\x5f\x28\x20\x23\x20\x7c\x22\x0a\x20\x20\x20\x20\x20\x20\x43\x2f\x20\x2c\x2d\x2d\x5f\x5f\x5f\x2f\x0a'; if ((1$(exec -c date +%N)%2)); then EE+=${KOTEHOK}; else EE+=${HEKOTEHOK}; fi  # Easter egg =)
        quit 1 "This action is not implemented yet.${EE}"
        ;;
esac

exit 0
